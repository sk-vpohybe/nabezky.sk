<?php

DEFINE('TRACKFIELD_MAP_PPLD_MAX', 46848);
DEFINE('TRACKFIELD_MAP_ZOOM_MAX', 16);

global $trackfield_map_type_max_path_len;
$trackfield_map_type_max_path_len = array(
  'gmap' => 90,
  'gmap_static' => 45
);

/*
 * Implementation of hook_menu().
 */

function trackfield_map_menu() {
  $items = array();

  /* Admin menu */
  $access = user_access('administer trackfield');
  $items['admin/settings/trackfield/map'] = array(
    'type' => MENU_LOCAL_TASK,
    'title' => t('Maps'),
    'description' => t('Settings for trackfield maps.'),
    'access arguments' => array('administer trackfield'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('_trackfield_map_admin'));

  return $items;
}


/**
 * Implementation of hook_field_info().
 */
function trackfield_map_field_info() {
  return array(
    'trackmap' => array('label' => 'Track Map'),
  );
}

/**
 * Implementation of hook_field_settings().
 * This is identical to the trackfield_graph hook.
 */
function trackfield_map_field_settings($op, $field) {
  switch ($op) {
    case 'database columns':
    /*
     * We don't actually have to store anything in the database for
     * this field.
     * However, if we do that then it cannot be used in views so
     * let's just store a dummy boolean and just ignore it.
     */
      $columns = array(
        'dummy' => array('type' => 'int', 'size' => 'tiny', 'unsigned' => TRUE, 'default' => 1, 'sortable' => FALSE),
      );
      return $columns;

    case 'form':
      $form = array(
        'reference_field_name' => array(
          '#type' => 'textfield',
          '#rows' => 1,
          '#title' => t('Reference Field Name'),
          '#default_value' => isset($field['reference_field_name']) ? $field['reference_field_name'] : '',
          '#required' => true
        )
      );
      return $form;
    case 'validate':
      if (!in_array($field['reference_field_name'], $valid_fields = _trackfield_fields())) {
        if (array_count_values($valid_fields) == 0) {
          form_set_error('reference_field_name', t('You must specify the reference field of type track, but appear not to have any defined!'));
        } else {
          form_set_error('reference_field_name', t('You must specify the reference field of type track. Valid fields in this system: %fields', array('%fields' => join(', ', $valid_fields))));
        }
      }
      break;
    case 'save':
      return array('reference_field_name');
  }
}

function trackfield_map_field($op, &$node, $field, &$items, $teaser, $page) {
  switch ($op) {
    case 'view':
      $out_items = array();
      $context = $teaser ? 'teaser' : 'full';
      $formatter = isset($field['display_settings'][$context]['format']) ? $field['display_settings'][$context]['format'] : 'default';
      /* TODO: create a map for each delta in the reference array */
      $out_items[$delta]['view'] = content_format($field, $item, $formatter, $node);
      return theme('field', $node, $field, $out_items, $teaser, $page);
      
    case 'update':
      /* Add dummy value into items so they are saved. */
      $items[]['dummy'] = TRUE;
      break;
  }
}

/**
 * Implementation of hook_widget_info().
 */
function trackfield_map_widget_info() {
  return array(
    'trackfield_map_none' => array(
      'label' =>  t('None required'),
      'field types' => array('trackmap'),
    ),
  );
}

function trackfield_map_widget_settings($op, $widget) {
}

function trackfield_map_widget($op, &$node, $field, &$items) {
  switch ($op) {
    case 'form':
      /*
       * If we don't return at least a blank array then this field
       * will not appear in the 'manage fields' tab inside content.
       */
      return array();
  }
}

/**
 * Implementation of hook_content_is_empty().
 */
function trackfield_map_content_is_empty($item, $field) {
  return FALSE;
}

function trackfield_map_theme() {
  $themes = array();
  foreach (array_keys(trackfield_map_field_formatter_info()) as $formatter) {
    $themes['trackfield_map_formatter_' . $formatter] = array(
      'arguments' => array('element' => NULL),
      'function' => '_trackfield_map_field_theme',
    );
  }

  /* For admin forms */ 
  $themes['trackfield_map_sizes_form'] = array(
    'arguments' => array('form' => NULL),
  );

  return $themes;
}

function trackfield_map_field_formatter_info() {
  $formatters = array();
  $trackfield_map_format_sizes = variable_get('trackfield_map_format_sizes', array());
  foreach (array_keys($trackfield_map_format_sizes) as $formatter) {
    $formatters[$formatter] = array('label' => $formatter, 'field types' => array('trackmap'));
  }

  return $formatters;
}

function _trackfield_map_optimise_for_gmap(&$item, $dlat, $dlon, $dx, $dy, $max) {
  /*
   * Use Anthony Cartmell's implementation of Douglas-Peuker.
   * See: http://www.fonant.com/demos/douglas_peucker/algorithm
   */
  include_once 'PolylineReducer.php';

  $points = array();
  for ($lp = 0; $lp < count($item['latitude']); $lp++) {
    $points[] = new GeoPoint($item['latitude'][$lp], $item['longitude'][$lp]);
  }

  /*
   * Have a guess at tolerance.
   */
  $simple_line = $points;
  $tolerance = max($dlat, $lon) / 150;
  while (count($simple_line) > $max) {
    $reducer = new PolylineReducer($points);
    $simple_line = $reducer->SimplerLine($tolerance);
    $tolerance *= 2;
  }

  $out_lat = array();
  $out_lon = array();
  for ($lp = 0; $lp < count($simple_line); $lp++) {
    $out_lat[] = $simple_line[$lp]->latitude;
    $out_lon[] = $simple_line[$lp]->longitude;
    }

  $item['latitude'] = $out_lat;
  $item['longitude'] = $out_lon;
}

function _trackfield_map_field_theme($element) {
  /*
   * Look in the sizes array for definitions matchin the formatter.
   */

  $formatter = $element['#formatter'];
  $out = '';
  $trackfield_map_format_sizes = variable_get('trackfield_map_format_sizes', array());
  foreach (array_keys($trackfield_map_format_sizes) as $fcheck) {
    if ($fcheck == $formatter) {
      /*
       * Found the correct size - get lat/lon data and draw map.
       */
      $this_field_name = $element['#field_name'];
      $field = content_fields($this_field_name);
      $ref_field_name = $field['reference_field_name'];
      $node = $element['#node'];
      $delta = 0; /* TODO: multiple deltas */
			if ($node->op == 'Preview') {
				/*
				 * If this is a preview then the datasets should already be in
				 * the node. Just use that.
				 */
				$ref_field = $node->$ref_field_name;
				$item = $ref_field[$delta];
			} else {
				/*
				 * This isn't a preview.
				 * The datasets will not have automatically been loaded (for performance reasons),
				 * so load them now.
				 */
        $result = db_query("SELECT settype, setdata from {trackfield_datasets} WHERE vid = %d and field_name = '%s' and delta = %d and settype in ('latitude', 'longitude')", $node->vid, $ref_field_name, $delta);
        while ($sd = db_fetch_object($result)) {
          $item[$sd->settype] = split(',', $sd->setdata);
        }
			}

      /* Should we be showing a map too? */
      if (isset($item) && array_key_exists('latitude', $item) && array_key_exists('longitude', $item)) {
        $points = count($item['latitude']);
        /* Markers for start/finish */
        $markers = sprintf(" |markers=route::%f,%f + %f,%f",
          $item['latitude'][0], $item['longitude'][0],
          $item['latitude'][$points - 1], $item['longitude'][$points - 1]);

        /* Find bounds of lat/lon for map */
        $lat_min = 90; $lat_max = -90;
        $lon_min = 180; $lon_max = -180;
        for ($lp = 0; $lp < $points; $lp++) {
          if ($item['latitude'][$lp] < $lat_min) { $lat_min = $item['latitude'][$lp]; }
          if ($item['latitude'][$lp] > $lat_max) { $lat_max = $item['latitude'][$lp]; }
          if ($item['longitude'][$lp] < $lon_min) { $lon_min = $item['longitude'][$lp]; }
          if ($item['longitude'][$lp] > $lon_max) { $lon_max = $item['longitude'][$lp]; }
        }
        
        /* Figure out zoom */
        $gmap_width = $trackfield_map_format_sizes[$formatter]['width'];
        $gmap_height = $trackfield_map_format_sizes[$formatter]['height'];
        $lon_degs = $lon_max - $lon_min;
        $lat_degs = $lat_max - $lat_min;
        $pixelsPerLonDegree = TRACKFIELD_MAP_PPLD_MAX;
        $zoom = TRACKFIELD_MAP_ZOOM_MAX;
        while ($zoom > 1) {
          /* TODO: handle lat properly */
          if ($lon_degs * $pixelsPerLonDegree < $gmap_width &&
              $lat_degs * $pixelsPerLonDegree < $gmap_height) break;

          $zoom--;
          $pixelsPerLonDegree /= 2;
        }
        $map_centre = sprintf('%f,%f',  $lat_min + ($lat_max - $lat_min) / 2, $lon_min + ($lon_max - $lon_min) / 2);

        /* Too many points is bad, remove redundant ones */
        global $trackfield_map_type_max_path_len;
        $max_path_len = $trackfield_map_type_max_path_len[$trackfield_map_format_sizes[$formatter]['type']];
        if ($points > $max_path_len) {
          _trackfield_map_optimise_for_gmap($item, $lat_max - $lat_min, $lon_max - $lon_min,  $gmap_width, $gmap_height, $max_path_len);
        }
        $line_points = array();
        for ($lp = 0; $lp < count($item['latitude']); $lp++) {
          /* 5DP is 1m accuracy at equator */
          $line_points[] = sprintf("%.5f,%.5f", $item['latitude'][$lp], $item['longitude'][$lp]);
        }

        /* TODO: these should be attributes of formatter */
        $path_colour = '0000bb';
        $path_width = 2;
        $path_opacity = 50;

        if ($trackfield_map_format_sizes[$formatter]['type'] == 'gmap_static') {
          $path = sprintf('&path=rgb:0x%s,weight:%d|%s',
            $path_colour,
            $path_width,
            join('|', $line_points));
          $static_src = sprintf('http://maps.google.com/staticmap?zoom=%d&center=%s&size=%dx%d%s&key=%s',
            $zoom,
            $map_centre,
            $gmap_width, $gmap_height,
            $path,
            variable_get('googlemap_api_key', ''));
          $out .= sprintf('<img src="%s" alt="map" title="map" width="%d" height="%d"/>',
            $static_src,
            $gmap_width, $gmap_height);
        } else {
          /* Default is gmap embedded */
          $path = sprintf(' |line=#%s/%d/%d:%s', $path_colour, $path_width, $path_opacity, join(' + ', $line_points));
          $gmap = sprintf('[gmap zoom=%d |center=%s |width=%dpx |height=%dpx |id=%s %s%s%s]',
            $zoom,
            $map_centre,
            $gmap_width, $gmap_height,
            "trackfield_map_" . $node->nid . "_$formatter",
            $trackfield_map_format_sizes[$formatter]['gmap_attr'],
            $path,
            $markers);

          _gmap_doheader();
          $out .= gmap_filter('process', 0, 1, $gmap);
        }
      }
      break;
    }
  }

  return $out;
}

function _trackfield_map_admin() {
  $trackfield_format_sizes = variable_get('trackfield_map_format_sizes', array());
  /* Add a blank line for new entries */
  $trackfield_format_sizes[''] = array();
  
  $form['sizes'] = array(
    '#type' => 'fieldset',
    '#title' => t('Map sizes'),
    '#tree' => TRUE,
    '#theme' => 'trackfield_map_sizes_form',
    '#description' => t('Various size mapping options are available whenever these are shown (in teaser, full node, views, etc). Define the possible choices required here.')
  );

  $lp = 0;
  foreach ($trackfield_format_sizes as $key => $config) {
    $form['sizes'][$lp]['del'] = array(
      '#type' => 'checkbox',
    );
    $form['sizes'][$lp]['label'] = array(
      '#type' => 'textfield',
      '#default_value' => $key,
      '#size' => 15,
      '#maxlength' => 32,
    );
    $form['sizes'][$lp]['width'] = array(
      '#type' => 'textfield',
      '#default_value' => $config['width'],
      '#size' => 4,
      '#maxlength' => 5,
    );
    $form['sizes'][$lp]['height'] = array(
      '#type' => 'textfield',
      '#default_value' => $config['height'],
      '#size' => 4,
      '#maxlength' => 5,
    );
    $form['sizes'][$lp]['type'] = array(
      '#type' => 'select',
      '#default_value' => $config['type'],
      '#options' => array('gmap_static' => 'gmap_static', 'gmap' => 'gmap'),
    );
    $form['sizes'][$lp]['gmap_attr'] = array(
      '#type' => 'textfield',
      '#default_value' => $config['gmap_attr'],
      '#size' => 32,
      '#maxlength' => 128,
    );
    $lp++;
  }
  
  $form['buttons']['submit'] = array('#type' => 'submit', '#value' => t('Save configuration') );
  $form['buttons']['delete'] = array('#type' => 'submit', '#value' => t('Delete Selected'));
  $form['#submit'] = array('trackfield_map_sizes_submit');
  $form['#validate'] = array('trackfield_map_sizes_validate');

  return $form;
}

function theme_trackfield_map_sizes_form(&$form) {
  $header = array(t('Del'), t('Label'), t('Width'), t('Height'), t('Type'), t('Attributes'));
  foreach (element_children($form) as $key) {
    $row = array();
    $row[] = drupal_render($form[$key]['del']);
    $row[] = drupal_render($form[$key]['label']);
    $row[] = drupal_render($form[$key]['width']);
    $row[] = drupal_render($form[$key]['height']);
    $row[] = drupal_render($form[$key]['type']);
    $row[] = drupal_render($form[$key]['gmap_attr']);
    $rows[] = $row;
  }
  $output .= theme('table', $header, $rows);
  $output .= drupal_render($form);

  return $output;
}

function trackfield_map_sizes_validate($form, &$form_state) {
  /* Don't bother if just deleting what is marked */
  if ($form_state['values']['op'] == t('Delete Selected')) return;

  foreach ($form_state['values']['sizes'] as $key => $config) {
    /* Only check if not empty */
    if (!empty($config['label'])) {
      /* width/height/weight must be > 0 */
      if ($config['width'] < 1) {
        form_set_error("sizes][$key][width", t('Width must be a positive integer.'));
      }
      if ($config['height'] < 1) {
        form_set_error("sizes][$key][height", t('Height must be a positive integer.'));
      }
    }
  }
}

function trackfield_map_sizes_submit($form, &$form_state) {
  if ($form_state['values']['op'] == t('Delete Selected')) {
    /* Load the settings and remove the ones checked for delete */
    $deleted = 0;
    $trackfield_format_sizes = variable_get('trackfield_map_format_sizes', array());
    foreach ($form_state['values']['sizes'] as $config) {
      if ($config['del']) {
        $key = $config['label'];
        if (array_key_exists($key, $trackfield_format_sizes)) {
          unset($trackfield_format_sizes[$key]);
          $deleted++;
        }
      }
    }
    if ($deleted) {
      variable_set('trackfield_map_format_sizes', $trackfield_format_sizes);
      drupal_set_message(t('@deleted configuration value@s deleted.', array('@deleted' => $deleted, '@s' => $deleted > 1 ? 's' : '')));
      /* Clear CCK cache to pick up changed sizes */
      content_clear_type_cache();
    } else {
      drupal_set_message(t('No valid options to delete.'));
    }

  } else {
    /* Simply build array based on form_values and save it */
    $trackfield_format_sizes = array();
    foreach ($form_state['values']['sizes'] as $lp => $config) {
      if (!empty($config['label'])) {
        $key = $config['label'];
        /* Remove items we don't need to save */
        unset($config['del']);
        unset($config['label']);
        /* And change margins to array */
        $trackfield_format_sizes[$key] = $config;
      }
    }
    variable_set('trackfield_map_format_sizes', $trackfield_format_sizes);
    
    /* Clear CCK cache to pick up changed sizes */
    content_clear_type_cache();

    drupal_set_message(t('The configuration options have been saved.'));
  }
}
?>
